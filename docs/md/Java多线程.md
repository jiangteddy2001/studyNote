# Java多线程

## 1 什么是JUC

JUC是java.util.concurrent 的简写，在并发编程中使用的工具类。

在jdk官方手册中可以看到juc相关的jar包有三个。

用中文概括一下，JUC的意思就是java并发编程工具包

实现多线程有三种方式：Thread、Runnable、Callable，其中Callable就位于concurrent包下



## 2 进程和线程

进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

## 3并行和并发

做并发编程之前，必须首先理解什么是并发，什么是并行。

并发和并行是两个非常容易混淆的概念。它们都可以表示两个或多个任务一起执行，但是偏重点有点不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。然而并行的偏重点在于”同时执行”。

严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一会运行任务一,一会儿又运行任务二，系统会不停地在两者间切换。但对于外部观察者来说，即使多个任务是串行并发的，也会造成是多个任务并行执行的错觉。

实际上，如果系统内只有一个CPU，而现在而使用多线程或者多线程任务，那么真实环境中这些任务不可能真实并行的，毕竟一个CPU一次只能执行一条指令，这种情况下多线程或者多线程任务就是并发的，而不是并行，操作系统会不停的切换任务。真正的并发也只能够出现在拥有多个CPU的系统中（多核CPU）。

**并发的动机**：在计算能力恒定的情况下处理更多的任务, 就像我们的大脑, 计算能力相对恒定, 要在一天中处理更多的问题, 我们就必须具备多任务的能力. 现实工作中有很多事情可能会中断你的当前任务, 处理这种多任务的能力就是你的并发能力。

**并行的动机**：用更多的CPU核心更快的完成任务. 就像一个团队, 一个脑袋不够用了, 一个团队来一起处理 一个任务。

例子： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 （不一定是 同时的） 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

## 4 synchronized和lock

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放 锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1 阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以 不用一直等待就结束了；
5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

## 5 常用工具类

### 5.1 CountDownLatch

CountDownLatch 主要有两个方法，当一个或多个线程调用 `await` 方法时，这些线程会阻塞

其他线程调用`CountDown()`方法会将计数器减1（调用CountDown方法的线程不会阻塞）

当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行



### 5.2 CyclicBarrier 

作用：和上面的减法相反，这里是加法，好比集齐7个龙珠召唤神龙，或者人到齐了再开会！



### 5.3 Semaphore 信号量

在信号量上我们定义两种操作：

- acquire（获取）

  当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）

  要么一直等下去，直到有线程释放信号量，或超时

- release （释放）

  会将信号量的值 + 1，然后唤醒等待的线程

信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。

## 6 线程池

池化技术简单点来说，就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化 技术可以大大的提高资源的利用率，提升性能等。

在编程领域，比较典型的池化技术有：**线程池、连接池、内存池、对象池等。**

我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核 CPU。当一个任务结束，当前线程就接收。

但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成很大的性能开销。

那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。

这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销。

### 6.1 优势

**线程池的优势：**

线程池做的工作主要是：控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这 些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

**它的主要特点为：线程复用，控制最大并发数，管理线程。**

第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。

第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。

### 6.2ThreadPoolExecutor 七大参数

查看三大方法的调用源码，发现本质都是调用了 new ThreadPoolExecutor ( 7 大参数 )

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {

}Copy to clipboardErrorCopied
```

1、`corePollSize`

核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。

2、`maximumPoolSize`

最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。

3、`keepAliveTime`

空闲的线程保留的时间，达到这个时间后，自动释放

4、`TimeUnit`

空闲线程的保留时间单位。

```java
TimeUnit.DAYS; //天
TimeUnit.HOURS; //小时
TimeUnit.MINUTES; //分钟
TimeUnit.SECONDS; //秒
TimeUnit.MILLISECONDS; //毫秒
TimeUnit.MICROSECONDS; //微妙
TimeUnit.NANOSECONDS; //纳秒Copy to clipboardErrorCopied
```

5、`BlockingQueue<Runnable> workQueue`

阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、 LinkedBlockingQueue、SynchronousQueue可选。

6、`ThreadFactory`

线程工厂，用来创建线程，一般默认即可

7、`RejectedExecutionHandler`

队列已满，而且任务量大于最大线程的异常处理策略。有以下取值

```java
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
```

![image-20221208162308853](https://jiangteddy.oss-cn-shanghai.aliyuncs.com/img2/202212081623928.png)

举例：8个人进银行办理业务

1、1~2人被受理（核心大小core）

2、3~5人进入队列（Queue）

3、6~8人到最大线程池（扩容大小max）

4、再有人进来就要被拒绝策略接受了



1、在创建了线程池后，开始等待请求。

2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：

- 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务
- 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
- 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非 核心线程立刻运行这个任务
- 如果队列满了且正在运行的线程数量大于或等于1Size，那么线程池会启动饱和拒绝策略来执行。

3、当一个线程完成任务时，它会从队列中取下一个任务来执行

4、 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断：

如果当前运行的线程数大于corePollSize，那么这个线程就被停掉。

所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。



### 6.3 线程池用哪个？生产中如何设置合理参数

**线程是否越多越好？**

一个计算为主的程序（专业一点称为**CPU密集型程序**）。多线程跑的时候，可以充分利用起所有的 cpu 核心，比如说4个核心的cpu，开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。但是如果线程远远超出cpu核心数量反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。

如果是一个磁盘或网络为主的程序（**IO密集型**）。一个线程处在IO等待的时候，另一个线程还可以在 CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。所以开多线程，比 方说多线程网络传输，多线程往不同的目录写文件，等等。此时线程数等于IO任务数是最佳的。