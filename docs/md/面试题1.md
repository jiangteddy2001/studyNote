# 面试题（东之晟）

## 1 数组和链表扩容机制

- 数组支持随机访问，而链表不支持。
- 数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。
- 数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！

## 2 Redis的持久化

Redis支持RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。

## 3 Redis数据类型

string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)

## 4 Spring处理循环依赖

循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：

![image-20221205161301260](https://jiangteddy.oss-cn-shanghai.aliyuncs.com/img2/202212051613307.png)

Spring中循环依赖场景主要有以下两种：
（1）field属性的循环依赖
（2）构造器的循环依赖
（3）DependsOn循环依赖

Spring为了解决单例的循环依赖问题，使用了三级缓存。

这三级缓存分别指：
singletonObjects：单例对象的cache
singletonFactories ： 单例对象工厂的cache
earlySingletonObjects ：提前暴光的单例对象的Cache

![image-20221205161501790](https://jiangteddy.oss-cn-shanghai.aliyuncs.com/img2/202212051615826.png)

测试证明，二级缓存也是可以解决循环依赖的。为什么 Spring 不选择二级缓存，而要额外多添加一层缓存呢？

如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理。所以，Spring 选择了三级缓存。但是因为循环依赖的出现，导致了 Spring 不得不提前去创建代理，因为如果不提前创建代理对象，那么注入的就是原始对象，这样就会产生错误。


## 5 HashMap为什么用红黑树

红黑树也是一种平衡二叉树，每个节点有一个储存位表示节点的颜色，可以是红色或者黑色。

对于插入删除等操作效率提高很多，插入、删除、查找各种操作性能都比较稳定

## 6Java多态

- **多态**是方法或对象具有**多种形态**，是**面向对象的第三大特征**。
- **多态**的**前提**是两个对象（类）存在**继承**关系，多态是建立在封装和继承基础之上的。

多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象：Parent p = new Child();

## 7 JDBC事务控制

conn.setAutoCommit(false); // 取消自动提交
conn.rollback();  //事务回滚
conn.commit(); //事务提交

SavePoint point = conn.setSavePoint(); // 设置事务保存点
conn.rollback(point); // 回滚到该保存点

## 8 Springboot和Springcloud区别

SpringBoot专注于快速方便的开发单个[微服务](https://so.csdn.net/so/search?q=微服务&spm=1001.2101.3001.7020)SpringCloud是关注全局微服务的协调整治治理框架

SpringBoot可以离开SpringCloud独立开发项目，但SpringCloud不能够离开SpringBoot

## 9 TCP、http\Https区别

TCP：传输控制协议
HTTP：超文本传输协议

http基于tcp连接，http协议中的数据是利用tcp协议传输的，所以支持http协议就能够支持tcp协议，tcp定义的是数据传输和连接方式的规范，http定义的是传输数据的内容的规范。

https=http+ssl（安全套接层）
http端口为80，数据是明文传输，数据安全性不高，连接无状态。
https端口为443，数据是加密进行传输的，比http安全，https协议需要用到CA证书，一般都是收费的，所以一些普通的网站基本都是用http协议。

## 10 事务的特性

- 原子性 指事务是一个不可分割的单位，事务中的操作要么都发生，要么都不发生
- 一致性 事务必须使数据库从一个一致性状态变换成另一个一致性状态
- 隔离性 一个事务的执行不能被其他事务干扰，各事务之间是隔离的
- 持久性 一个事务一旦被提交，对数据库中的数据的改变就是永久的

## 11 redis实现分布式事务

redis中自带的事务命令，最致命就是不保证原子性，所以在使用redis的事务时，一定要谨慎。redis中可以通过Lua实现真正的事务操作。

redis来做分布式锁





## 12 如何实现Redis的高可用？

实现Redis的高可用，主要有哨兵和集群两种方式。

哨兵：

Redis Sentinel（哨兵）是一个分布式架构，它包含若干个哨兵节点和数据节点。每个哨兵节点会对数据节点和其余的哨兵节点进行监控，当发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它就会与其他的哨兵节点进行协商，当多数哨兵节点都认为主节点不可达时，它们便会选举出一个哨兵节点来完成自动故障转移的工作，同时还会将这个变化实时地通知给应用方。整个过程是自动的，不需要人工介入，有效地解决了Redis的高可用问题！

集群：

Redis集群采用虚拟槽分区来实现数据分片，它把所有的键根据哈希函数映射到0-16383整数槽内，计算公式为slot=CRC16(key)&16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。

## 13 插入排序比冒泡排序快？为什么？

同为稳定性排序算法，时间复杂度也一样，插入排序的效率比冒泡排序要好，尤其是数据量大的时候，差距更明显。为什么？

冒泡排序移动数据的操作更多，只要是小于后一个元素，就移动一次。所以它的效率低。

## 14 spring事务控制

Spring支持两种事务编程模型：

1. 编程式事务

   Spring提供了TransactionTemplate模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。

2. 声明式事务

   Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。

## 15 spring设计模式

![image-20221205163021909](https://jiangteddy.oss-cn-shanghai.aliyuncs.com/img2/202212051630952.png)

## 16 MQ怎么解决消息丢失和重复消费

丢数据一般分为两种，一种是mq把消息丢了，一种就是消费时将消息丢了。

总体的方案：在消息生产端，给发出的每一个消息指定一个全局唯一的ID，在消费端做校验。

解决重复：

在数据库中建一个消息日志表，这个表记录消息ID和消息执行状态。

## 17HashMap如何解决Hash冲突

为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时，会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时，又会将红黑树转换回单向链表提高性能。

